{"meta":{"title":"非洲卖红薯的","subtitle":"记录更多的世界","description":"记录更多的世界","author":"非洲卖红薯的","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"TS入门-hello world","slug":"TS入门-hello-world","date":"2019-01-01T07:56:55.000Z","updated":"2019-01-01T08:03:27.761Z","comments":true,"path":"2019/01/01/TS入门-hello-world/","link":"","permalink":"http://yoursite.com/2019/01/01/TS入门-hello-world/","excerpt":"","text":"一、简介TypeScript是微软开发的开源编程语言，它是Javascript的超集。 二、开发环境 安装node.js，TypeScript需要编译成Javascript才能运行，Node.js提供了编译环境。 安装TypeScript编译工具，打开cmd，输入npm命令： 1npm install -g typescript 安装成功如图： 如果安装的过程中出现以下错误 请执行以下命令，将npm镜像地址切换到国内 npm –registry http://registry.cnpmjs.org 三、Hello World新建文件Hello.ts，用记事本打开，并输入以下代码：1234function hello()&#123; return &apos;Hello World&apos;&#125;console.log(hello()); 这段代码将在console中输出Hello World ts文件为TypeScipt的后缀名，我们需要将TypeScript编译成Js，在命令行中输入以下命令执行编译:1tsc hello.ts 命令执行后会在同目录生成Hello.js，为TypeScript编译文件 我们用Node.js运行该js文件，如图： 一个简单的Hello World程序就出来了","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"终端之美-目录相关的命令","slug":"终端之美-目录相关的命令","date":"2018-12-22T14:49:36.000Z","updated":"2018-12-22T15:44:24.477Z","comments":true,"path":"2018/12/22/终端之美-目录相关的命令/","link":"","permalink":"http://yoursite.com/2018/12/22/终端之美-目录相关的命令/","excerpt":"cd 切换用户当前目录用来切换用户当前目录当指定目录，这个指定目录可以是相对路径也可以是绝对路径一些常用的特殊符号： ~ 用户主目录 . 当前目录 .. 上一级目录 命令示例：1234cd ~ //切换到用户主目录cd /home //进入home目录cd ../ //进入上一级目录cd ../code //进入上一级目录下的code目录","text":"cd 切换用户当前目录用来切换用户当前目录当指定目录，这个指定目录可以是相对路径也可以是绝对路径一些常用的特殊符号： ~ 用户主目录 . 当前目录 .. 上一级目录 命令示例：1234cd ~ //切换到用户主目录cd /home //进入home目录cd ../ //进入上一级目录cd ../code //进入上一级目录下的code目录 ls 显示指定目录下的文件和文件夹用来查看当前目录或指定目录下的有那些文件和文件夹一些常用参数： -a 显示全部文件 -l 所有信息用单列显示 -s 显示文件和目录的大小 -r 以文件名反序排列并输出目录内容列表 命令示例：123ls -a //列出当前文件夹下全部文件，包括隐藏文件ls -ls //以单列显示文件信息包括文件大小ls /home //显示home文件夹下的文件 pwd 显示用户当前工作路径用来显示用户当前的工作路径的 ，以绝对路径的形式呈现的命令示例：1pwd ///home/liguifa/codes mkdir 创建文件夹用来创建文件夹，如果没有指定路径则在当前目录下创建命令示例：123mkdir test1 //在当前目录下目录下创建名为test1的文件夹mkdir ../test2 //在上一级目录下创建名为test2的文件夹mkdir /home/test3 //在home目录下创建名为test3的文件夹 rm 删除文件或文件夹用于删除文件或文件夹，如果不指定-r参数，则为删除文件一些常用参数： -r 删除文件夹 -f 强制删除 -v 显示删除过程 命令示例：123rm test.zip //删除当前目录下的test.zip文件rm ../test.zip //删除上一级目录下的test.zip文件夹rm -rfv /home/codes //强制删除home文件夹下的codes文件夹，并显示删除过程 mv 移动文件或文件夹用于移动文件或文件夹，指定-f参数，为移动文件夹，如果在目标位置和源位置相同则为重命名一些常用参数： -r 移动文件夹 -f 强制移动 -v 显示删除过程 命令示例：1234mv ../1.zip ../2.zip //重命名上一级目录下的1.zip为2.zipmv ../3.zip ../../4.zip //将上一级的3.zip移动到上上一级并修改名称为4.zipmv /home/5.zip ~/ //移动home目录下的5.zip到用户主目录下mv -r /home/codes ~/ //移动home目录下的codes文件到用户主目录下 cp 复制文件或文件夹用来将一个或多个源文件或者目录复制到指定的目的文件或目录一些常用参数： -r 复制文件夹 -f 强制复制 -v 显示复制过程 12cp 1.zip ../ //复制当前目录下的1.zip到上一级目录下cp -r test /home //复制当前目录下的test文件夹到上一级目录 scp 远程复制文件或文件夹用于在两台主机之间复制文件或文件夹一些常用参数： -r 复制文件夹 -f 强制复制 -v 显示复制过程 命令示例：123scp ./2.zip liguifa@192.168.112.15:/home/iknow/ //将当前目录下的2.zip复制到192.168.112.15这台主机下的home/iknow文件夹下scp -r liguifa@192.168.112.15:/home/codes ./ //将192.168.112.15这台主机下的home/codes文件夹复制到当前目录下/* 远程机器路径：用户名@ip:目录 */ tree 列出目录内容用于以树状图列出目录的内容该命令需要执行安装123brew install tree //Mac安装yum install tree //center os安装apt-get install tree //ubuntu安装 一些常用参数： -F 文件夹后面加上/ -C 彩色输出 命令示例：12tree ./public //列出public下的结构tree ./ | grep 04 //列出当前目录的结构并执行搜索","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"mac设置ssh不掉线","slug":"mac设置ssh不掉线","date":"2018-12-19T08:51:50.000Z","updated":"2018-12-19T08:55:49.780Z","comments":true,"path":"2018/12/19/mac设置ssh不掉线/","link":"","permalink":"http://yoursite.com/2018/12/19/mac设置ssh不掉线/","excerpt":"我们在mac下面用终端连接远程服务器, 如果长时间不操作, 会发现连接会断开, 所以不得不重新连接, 很多时候我们不希望出现这种情况, 这个时候可以在服务器或者客户端设置mac客户端设置","text":"我们在mac下面用终端连接远程服务器, 如果长时间不操作, 会发现连接会断开, 所以不得不重新连接, 很多时候我们不希望出现这种情况, 这个时候可以在服务器或者客户端设置mac客户端设置123456# 打开vi ~/.ssh/config# 添加, 60s向服务端请求一次ServerAliveInterval = 60# 设置文件权限chmod 600 ~/.ssh/config 切记, 权限一定要设置否则没有效果 Linux服务器设置12345# 打开(服务端是文件 sshd_config)vi /etc/ssh/sshd_config# 添加ClientAliveInterval 60ClientAliveCountMax 1 SSH Server 每 60 秒就会自动发送一个信号给 Client，而等待 Client 回应","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"Homebrew安装","slug":"Homebrew安装","date":"2018-12-19T05:49:03.000Z","updated":"2018-12-19T07:02:52.628Z","comments":true,"path":"2018/12/19/Homebrew安装/","link":"","permalink":"http://yoursite.com/2018/12/19/Homebrew安装/","excerpt":"脚步安装在命令行中输入并执行1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;","text":"脚步安装在命令行中输入并执行1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 出现下面显示，按回车之后出现下图表示安装成功 测试安装在命令行中输入并执行1brew help 出现下图表示brew无误","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"Chrome devtool是用指南","slug":"Chrome-devtool是用指南","date":"2018-12-18T04:18:45.000Z","updated":"2018-12-18T09:37:57.698Z","comments":true,"path":"2018/12/18/Chrome-devtool是用指南/","link":"","permalink":"http://yoursite.com/2018/12/18/Chrome-devtool是用指南/","excerpt":"在这篇文章中，我们会用Performance工具去分析一个现有的在线DEMO，然后教会你怎么去分析，从而找到性能瓶颈。 打开Chrome的匿名模式。匿名模式可以保证Chrome在一个相对干净的环境下运行。比如说，你安装了许多chrome插件，这些插件可能会影响我们分析性能表现。 在匿名模式下打开右边这个链接，DEMO，这个网页就是我们要用来分析的DEMO。这个页面里都是很多上下移动的蓝色小方块。 按下Command+Opiton+I（Mac）或者Control+shift+I (Windows, Linux) 来打开Devtools","text":"在这篇文章中，我们会用Performance工具去分析一个现有的在线DEMO，然后教会你怎么去分析，从而找到性能瓶颈。 打开Chrome的匿名模式。匿名模式可以保证Chrome在一个相对干净的环境下运行。比如说，你安装了许多chrome插件，这些插件可能会影响我们分析性能表现。 在匿名模式下打开右边这个链接，DEMO，这个网页就是我们要用来分析的DEMO。这个页面里都是很多上下移动的蓝色小方块。 按下Command+Opiton+I（Mac）或者Control+shift+I (Windows, Linux) 来打开Devtools 模拟移动设备的CPU 移动设备的CPU一般比台式机和笔记本弱很多。当你想分析页面的时候，可以用CPU控制器（CPU Throttling）来模拟移动端设备CPU。 在DevTools中，点击 Performance 的 tab。 确保 Screenshots checkbox 被选中 点击 Capture Settings（⚙️）按钮，DevTools会展示很多设置，来模拟各种状况 对于模拟CPU，选择2x slowdown，于是Devtools就开始模拟两倍低速CPU设置DEMO 为了使得这个DEMO有相对统一的运行表现（不同的读者，机器的性能千差万别）。这个DEMO提供了自定义功能，用来确保这个DEMO的统一表现。 一直点击 Add 10 这个按钮直到你能很明显看到蓝色小方块移动变慢，在性能比较好的机器上，大概要点击20次左右。 点击 Optimize按钮，你会发现蓝色小方块会变的很快而且动画变得平滑。 点击 un-optimize 按钮，蓝色小方块又会变成之前的模样。记录运行时性能表现 在之前的DEMO中，当你运行优化模式的时候，蓝色小方块移动地非常快。为什么呢？明明两个模式都是移动了同样数量的小方块而且移动的时间也一样。那么现在我们在Performance界面下录制下发生的一切，并且学习如何分析这个记录，从而找到非优化模式下的性能瓶颈。 在DevTools中，点击 Record 。这时候Devtools就开始录制各种性能指标 等待几分钟 点击Stop按钮，Devtools停止录制，处理数据，然后显示性能报告wow，看起来有非常多的数据，别害怕，我们一个一个来介绍分析报告 一旦你得到了页面的性能表现报告，那么就可以用它来分析页面的性能，从而找到性能瓶颈。分析每一秒的帧 FPS（frames per second）是用来分析动画的一个主要性能指标。能保持在60的FPS的话，那么用户体验就是不错的。 观察FPS图表，如果你发现了一个红色的长条，那么就说明这些帧存在严重问题，有可能导致非常差的用户体验。一般来说，绿色的长条越高，说明FPS越高，用户体验越好。 就在FPS图表下方，你会看到CPU图表。在CPU图表中的各种颜色与Summary面板里的颜色是相互对应的，Summary面板就在Performance面板的下方。CPU图表中的各种颜色代表着在这个时间段内，CPU在各种处理上所花费的时间。如果你看到了某个处理占用了大量的时间，那么这可能就是一个可以找到性能瓶颈的线索。 把鼠标移动到FPS，CPU或者NET图表之上，DevToos就会展示这个时间点界面的截图。左右移动鼠标，可以重发当时的屏幕录像。这被称为scrubbing, 他可以用来分析动画的各个细节。 在Frames图表中，把鼠标移动到绿色条状图上，Devtools会展示这个帧的FPS。每个帧可能都在60以下，都没有达到60的标准。当然这个对于DEMO，可以相当容易观察到性能的问题。但是在现实使用场景下，就不是那么容易观察到了。所以要把常常使用这些工具来分析页面。小功能：显示实时FPS面板另外一个好用的小工具就是实时FPS面板，它可以实时展示页面的FPS指标 按下 Command+Shift+P（Mac）或者 Control+Shift+P(Windows, Linux) 打开命令菜单 输入Rendering，点选Show Rendering 在Rendering面板里，激活FPS Meter。FPS实时面板就出现在页面的右上方。 关闭FPS Meter只要按下Escape就可以了。这篇指南里暂时用不上这个功能。定位瓶颈 现在已经确定到这个页面的动画性能表现不太好，那么下一步就是找到为什么 注意Summary面板，你会发现CPU花费了大量的时间在rendering上。因为提高性能就是一门做减法的艺术，你的目标就是减少rendering的时间 展开Main图表，Devtools展示了主线程运行状况。X轴代表着时间。每个长条代表着一个event。长条越长就代表这个event花费的时间越长。Y轴代表了调用栈（call stack）。在栈里，上面的event调用了下面的event。 在性能报告中，有很多的数据。可以通过双击，拖动等等动作来放大缩小报告范围，从各种时间段来观察分析报告。 在事件长条的右上角出，如果出现了红色小三角，说明这个事件是存在问题的，需要特别注意。 双击这个带有红色小三角的的事件。在Summary面板会看到详细信息。注意reveal这个链接，双击它会让高亮触发这个事件的event。如果点击了app.js:94这个链接，就会跳转到对应的代码处。 在app.update这个事件的长条下方，有很多被触发的紫色长条。如果放大这些事件长条，你会看到它们每个都带有红色小三角。点击其中一个紫色事件长条，Devtools在Summary面板里展示了更多关于这个事件的信息。确实，这里有很多reflow的警告。 在summary面板里点击app.js:70链接，Devtools会跳转到需要优化的代码处OK！Devtools里面还有很多很多指标需要你去探索，但是，对于怎么用Devtools去分析网页的运行时性能表现，你现在已经有了一个基本的概念。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"hadoop常用命令","slug":"hadoop常用命令","date":"2018-12-15T13:51:08.000Z","updated":"2018-12-15T13:53:15.445Z","comments":true,"path":"2018/12/15/hadoop常用命令/","link":"","permalink":"http://yoursite.com/2018/12/15/hadoop常用命令/","excerpt":"FS Shell调用文件系统(FS)Shell命令应使用 bin/hadoop fs 的形式。 所有的的FS shell命令使用URI路径作为参数。URI格式是scheme://authority/path。对HDFS文件系统，scheme是hdfs，对本地文件系统，scheme是file。其中scheme和authority参数都是可选的，如果未加指定，就会使用配置中指定的默认scheme。一个HDFS文件或目录比如/parent/child可以表示成hdfs://namenode:namenodeport/parent/child，或者更简单的/parent/child（假设你配置文件中的默认值是namenode:namenodeport）。大多数FS Shell命令的行为和对应的Unix Shell命令类似，不同之处会在下面介绍各命令使用详情时指出。出错信息会输出到stderr，其他信息输出到stdout。","text":"FS Shell调用文件系统(FS)Shell命令应使用 bin/hadoop fs 的形式。 所有的的FS shell命令使用URI路径作为参数。URI格式是scheme://authority/path。对HDFS文件系统，scheme是hdfs，对本地文件系统，scheme是file。其中scheme和authority参数都是可选的，如果未加指定，就会使用配置中指定的默认scheme。一个HDFS文件或目录比如/parent/child可以表示成hdfs://namenode:namenodeport/parent/child，或者更简单的/parent/child（假设你配置文件中的默认值是namenode:namenodeport）。大多数FS Shell命令的行为和对应的Unix Shell命令类似，不同之处会在下面介绍各命令使用详情时指出。出错信息会输出到stderr，其他信息输出到stdout。 cat使用方法：hadoop fs -cat URI [URI …]将路径指定文件的内容输出到stdout。示例： hadoop fs -cat hdfs://host1:port1/file1 hdfs://host2:port2/file2 hadoop fs -cat file:///file3 /user/hadoop/file4返回值：成功返回0，失败返回-1。chgrp使用方法：hadoop fs -chgrp [-R] GROUP URI [URI …] Change group association of files. With -R, make the change recursively through the directory structure. The user must be the owner of files, or else a super-user. Additional information is in the Permissions User Guide. –&gt;改变文件所属的组。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。更多的信息请参见HDFS权限用户指南。chmod使用方法：hadoop fs -chmod [-R] &lt;MODE[,MODE]… | OCTALMODE&gt; URI [URI …]改变文件的权限。使用-R将使改变在目录结构下递归进行。命令的使用者必须是文件的所有者或者超级用户。更多的信息请参见HDFS权限用户指南。chown使用方法：hadoop fs -chown [-R] [OWNER][:[GROUP]] URI [URI ]改变文件的拥有者。使用-R将使改变在目录结构下递归进行。命令的使用者必须是超级用户。更多的信息请参见HDFS权限用户指南。copyFromLocal使用方法：hadoop fs -copyFromLocal URI除了限定源路径是一个本地文件外，和put命令相似。copyToLocal使用方法：hadoop fs -copyToLocal [-ignorecrc] [-crc] URI 除了限定目标路径是一个本地文件外，和get命令类似。cp使用方法：hadoop fs -cp URI [URI …] 将文件从源路径复制到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。示例： hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 hadoop fs -cp /user/hadoop/file1 /user/hadoop/file2 /user/hadoop/dir返回值：成功返回0，失败返回-1。du使用方法：hadoop fs -du URI [URI …]显示目录中所有文件的大小，或者当只指定一个文件时，显示此文件的大小。示例：hadoop fs -du /user/hadoop/dir1 /user/hadoop/file1 hdfs://host:port/user/hadoop/dir1返回值：成功返回0，失败返回-1。 dus使用方法：hadoop fs -dus 显示文件的大小。expunge使用方法：hadoop fs -expunge清空回收站。请参考HDFS设计文档以获取更多关于回收站特性的信息。get使用方法：hadoop fs -get [-ignorecrc] [-crc] 复制文件到本地文件系统。可用-ignorecrc选项复制CRC校验失败的文件。使用-crc选项复制文件以及CRC信息。示例： hadoop fs -get /user/hadoop/file localfile hadoop fs -get hdfs://host:port/user/hadoop/file localfile返回值：成功返回0，失败返回-1。getmerge使用方法：hadoop fs -getmerge [addnl]接受一个源目录和一个目标文件作为输入，并且将源目录中所有的文件连接成本地目标文件。addnl是可选的，用于指定在每个文件结尾添加一个换行符。ls使用方法：hadoop fs -ls 如果是文件，则按照如下格式返回文件信息：文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下：目录名 修改日期 修改时间 权限 用户ID 组ID示例：hadoop fs -ls /user/hadoop/file1 /user/hadoop/file2 hdfs://host:port/user/hadoop/dir1 /nonexistentfile返回值：成功返回0，失败返回-1。 lsr使用方法：hadoop fs -lsr ls命令的递归版本。类似于Unix中的ls -R。 mkdir使用方法：hadoop fs -mkdir 接受路径指定的uri作为参数，创建这些目录。其行为类似于Unix的mkdir -p，它会创建路径中的各级父目录。示例： hadoop fs -mkdir /user/hadoop/dir1 /user/hadoop/dir2 hadoop fs -mkdir hdfs://host1:port1/user/hadoop/dir hdfs://host2:port2/user/hadoop/dir返回值：成功返回0，失败返回-1。movefromLocal使用方法：dfs -moveFromLocal 输出一个”not implemented“信息。mv使用方法：hadoop fs -mv URI [URI …] 将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。示例： hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2 hadoop fs -mv hdfs://host:port/file1 hdfs://host:port/file2 hdfs://host:port/file3 hdfs://host:port/dir1返回值：成功返回0，失败返回-1。put使用方法：hadoop fs -put … 从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。 hadoop fs -put localfile /user/hadoop/hadoopfile hadoop fs -put localfile1 localfile2 /user/hadoop/hadoopdir hadoop fs -put localfile hdfs://host:port/hadoop/hadoopfile hadoop fs -put - hdfs://host:port/hadoop/hadoopfile从标准输入中读取输入。返回值：成功返回0，失败返回-1。rm使用方法：hadoop fs -rm URI [URI …]删除指定的文件。只删除非空目录和文件。请参考rmr命令了解递归删除。示例： hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir返回值：成功返回0，失败返回-1。rmr使用方法：hadoop fs -rmr URI [URI …]delete的递归版本。示例： hadoop fs -rmr /user/hadoop/dir hadoop fs -rmr hdfs://host:port/user/hadoop/dir返回值：成功返回0，失败返回-1。setrep使用方法：hadoop fs -setrep [-R] 改变一个文件的副本系数。-R选项用于递归改变目录下所有文件的副本系数。示例： hadoop fs -setrep -w 3 -R /user/hadoop/dir1返回值：成功返回0，失败返回-1。stat使用方法：hadoop fs -stat URI [URI …]返回指定路径的统计信息。示例： hadoop fs -stat path返回值：成功返回0，失败返回-1。tail使用方法：hadoop fs -tail [-f] URI将文件尾部1K字节的内容输出到stdout。支持-f选项，行为和Unix中一致。示例： hadoop fs -tail pathname返回值：成功返回0，失败返回-1。test使用方法：hadoop fs -test -[ezd] URI选项：-e 检查文件是否存在。如果存在则返回0。-z 检查文件是否是0字节。如果是则返回0。-d 如果路径是个目录，则返回1，否则返回0。示例： hadoop fs -test -e filenametext使用方法：hadoop fs -text 将源文件输出为文本格式。允许的格式是zip和TextRecordInputStream。touchz使用方法：hadoop fs -touchz URI [URI …]创建一个0字节的空文件。示例： hadoop fs -touchz pathname返回值：成功返回0，失败返回-1。","categories":[],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/大数据/"}]},{"title":"Redis常用命令","slug":"Redis常用命令","date":"2018-12-15T10:15:52.000Z","updated":"2018-12-15T10:21:31.484Z","comments":true,"path":"2018/12/15/Redis常用命令/","link":"","permalink":"http://yoursite.com/2018/12/15/Redis常用命令/","excerpt":"","text":"# 命令 参数 例子 功能 返回值 原理 1 keys pattern: 键名配置模式 keys * 输出所有键 返回键列表 遍历所有键，和输入的模式做匹配，时间复杂度为O(n)，当Redis保存大量键时，线上环境禁止使用 2 dbsize dbsize 获取键总数 返回键总数 直接获取Redis内置键总数变量，时间复杂度为O(1) 3 exists key: 键名 exists key 检查键是否存在 1：键存在 0：键不存在 4 del key: 键名列表 del key1 key2 删除键 1：删除成功 0：键不存在 5 expire key: 键名 seconds:过期时间 expire key1 10 键过期 1：设置成功 0：键不存在 6 ttl key:键名 ttl key1 获取剩余过期时间 &gt;=0：键剩余的过期时间 -1：键没有设置过期时间 -2：键不存在 7 type key: 键名 type key1 获取键的数据类型 返回键类型 如果键不存在则返回none 8 set key: 键名 value: 值 set name hello 设置键 9 get key:键名 get name 获取键值 键值","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"灵活的DBContext生命周期管理","slug":"灵活的DBContext生命周期管理","date":"2018-12-15T10:15:52.000Z","updated":"2018-12-15T14:34:39.013Z","comments":true,"path":"2018/12/15/灵活的DBContext生命周期管理/","link":"","permalink":"http://yoursite.com/2018/12/15/灵活的DBContext生命周期管理/","excerpt":"我们在开发过程中总是回遇到的许多架构上的问题，在这些架构问题中，最常见的是 DbContext 生命周期的管理以及跨域调用时遇到的 request 上下文限制的问题。","text":"我们在开发过程中总是回遇到的许多架构上的问题，在这些架构问题中，最常见的是 DbContext 生命周期的管理以及跨域调用时遇到的 request 上下文限制的问题。&nbsp;首先说说 DBContext的Scope 定义问题。根据微软的建议， DBContext是一个轻量级的，类似于 Unit of work模式的实体上下文，其生命周期对应一次业务操作，比如一次 REST API 调用，一次线程中的批处理业务等等，但总的原则是其生命周期应该尽可能短，另外 DBContext的生命周期也隐含地对应一次数据库事务。&nbsp;DBContext生命周期定义有许多的方式，如在一个 DAO函数中创建 DBContext，并在离开函数前销毁的模式，或者在HTTP request开头创建，在 HTTP request结尾销毁的模式，这些模式各有利弊，在一个 DAO函数中创建 DBContext这中模式较好地避免了死锁的发生，但是频繁且碎片化的生命周期导致事务完全失效且对性能有一定的影响，HTTP request的方式灵活性较差，一旦脱离 web上下文，就难以找到更合适的粒度，并且完全依赖运行环境上下文的模式为业务的在不同环境下的复用带来了较大的限制。 这个DBContext的模式有一个共同的问题，就是 DBContext生命周期的定义是不可变的，不能根据业务的需要进行覆盖和重新定义 ，这也是导致我们目前开发中遇到各种问题和障碍的主要原因。&nbsp;DBContext以及其对应的生命周期归根到底是一种资源（类似于 Session），既然是资源，就应该被灵活使用， 在不同的运行环境中拥有不同的行为，而在我们开发 Service和业务逻辑时，并不能完全确定资源的使用方式，我们可以定义 DBContext在当前业务下的生命周期，但是当局部的业务逻辑被放到更大或者完全不同的业务层面中时，作为资源（ Session）是需要被重新定义以适应新的业务上下文的。所以，我们需要一种可以在任何粒度下使用，并可以按需覆盖的 DBContext生命周期管理架构，以便我们在任何业务上下文中都能灵活控制事务和生命周期。&nbsp;针对这个需求，目前已经有不少成熟的思路和解决方案，比较好的是DbContextScope模式和其对应的开源代码，可以参考其在 GitHub上的工程：&nbsp;https://github.com/mehdime/DbContextScope&nbsp;DbContextScope使用.Net 的CallContext机制（ http://www.cnblogs.com/vwxyzh/archive/2009/02/21/1395416.html ）来实现同一调用上下文中资源的共享，其典型的调用方式如下面的截图所示：使用中在 Service层中每个可能被单独调用的方法中显示声明 DBContextScope，当同一AppDomain 中如果有嵌套调用，最外部的 scope会保证所有内部的scope都使用同一个 DBContext，保证了事务和生命周期能被灵活的管理，大家还可以根据不同的业务来选择最合适的 scope，但是即使大家没有精力考虑生命周期的合理定义，也只需要简单的在所有函数中都加上 DBContextScope，就能保证适应绝大多数的调用场景。使用这种模式后，大家也不再需要依赖 HTTP Request或者将Service 声明为多实例，为开发提供更多的灵活性。&nbsp;另外针对跨域调用的限制， CallContext也是解决该问题的合理方案， Plugin Framework随后会提供一套统一的框架共大家在跨域调用时将必要的资源上下文通过 CallContext跨域传递给被调用方，包括在 Web Controller中对跨同一AppDomain 的service多次调用的 DBContext的生命周期进行统一管理，以及提供方法让大家将 HTTP Context中的必要信息传递给跨域的 Service层。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"JavaScript作用域","slug":"JavaScript作用域","date":"2018-12-15T08:56:15.000Z","updated":"2018-12-15T09:54:56.106Z","comments":true,"path":"2018/12/15/JavaScript作用域/","link":"","permalink":"http://yoursite.com/2018/12/15/JavaScript作用域/","excerpt":"JaveScript 是Web前端开发的最重要的语言，在JavaScript中作用域是一个重要的基础知识点。在JavaScript中共有三种作用域，分别是全局作用域、函数左右域和块级作用域。本文会先对三种作用域做介绍，之后举一个常见的例子做整体介绍。","text":"JaveScript 是Web前端开发的最重要的语言，在JavaScript中作用域是一个重要的基础知识点。在JavaScript中共有三种作用域，分别是全局作用域、函数左右域和块级作用域。本文会先对三种作用域做介绍，之后举一个常见的例子做整体介绍。 1、全局作用域全局作用域，故名思议，全局作用域就是整个JavaScript代码范围。如下代码所示: var a = &quot;Hello&quot;;console.log(a); //Hellofor(var i in a){ console.log(a[i]); //H、e、l、l、o} console.log(i); // 4}function func(){ console.log(a); //Hello console.log(i) // 4}func();在这段代码中，我们先声明了变量a，并对a赋值Hello，a是我们在全局上声明的变量，此时a的作用域为全局作用域，我们之后在直接输出、循环中输出、函数中输出都没有错误，说明此时a在任何位置均可以访问。同时在for循环中我们声明了变量i，for循环结束之后变量i并没有释放，而是输出了最后的值4，说明此时变量i的作用域为全局作用域。 2、函数作用域函数作用域，故名思议，函数作用域就是生个函数范围。如下代码所示: function fun() { var a = &quot;Hello&quot;; var i = 0; switch (i) { case 0: console.log(a); //hello } console.log(a); //hello}func();console.log(a); //Errorvar t = &quot;hello2&quot;;function fun2() { var t = &quot;helllo3&quot;; console.log(t); //hello3}在这段代码中，我们先声明了函数fun，在函数内部我们声明了变量a，此时a的作用域为函数作用域，之后我们在switch中输出，尽管我们的switch被大括号包裹，但是我们依然可以访问，说明函数作用域可以在函数的任意位置范围，之后在函数之外，我们输出变量a，此时就会出错，因为变量a的作用域为函数作用域，在函数为无法访问。在fun2中，我们声明了一个与全局变量同名的变量t，此时函数作用域中的t为覆盖全局作用域的t，这里的规则是子作用域覆盖父作用域，而全局作用域做为所有作用域的顶层作用域，一定会被子作用域的同名变量覆盖。 3、块级作用域在ES6中，JavaScript引入了块级作用域，块级作用域的作用域范围为代码块。如下代码所示： &quot;use strict&quot;{ var a = 0; console.log(a);}console.log(a) //Error在上面代码中，我们使用use strict启用ES6，此时块级作用域起效，在之后的代码块中，变量a为块级作用域，在代码中访问正常，而在代码我们无法访问，与函数作用域类似，我们依然可以访问父作用域的变量，当发生变量重名是会覆盖父作用域的变量。 4、例子与作用域相关的问题中，大多出在for中，如下代码所示： var funcs = [];for(var i = 0;i&lt;4;i++)&nbsp;{ funcs.push(function()&nbsp;{ console.log(i); });}funcs.forEach(function()&nbsp;{ fun();});我们执行这段代码，此时我们期望输出0、1、2、3，但是在实际运行时，我们输出了4、4、4、4，这是因为var声明的变量只能是全局作用域或函数作用域，如果我们这段代码运行在全局作用域的，那么变量i的作用域就是全局作用域，在整个作用域中变量i只有一个值，也就是在funs中我们引用的变量i和全局作用域的i是同一个并且只有一个，当循环结束后，变量的值变成了4，我们在执行funs，那么输出的就是变量i的值4。那么很明显这个问题是作用域没有独立引起的，解决办法就是新建一样作用域。 4.1 方法1var funcs = [];for (var i = 0; i &lt; 4; i++) { funcs.push((function (in_i) { return function () { console.log(in_i); } })(i));}funcs.forEach(function () { fun();});如上面的代码所示，我们使用闭包，闭包就是一个立即执行的函数，此时我们使用闭包新建了一个函数作用域，并把变量i参入，在闭包内部会拷贝一份变量i到in_i，此时for内部不再是单一作用域，做个作用域有多个in_i。 4.2 方法2var funcs = [];for(let i = 0;i&lt;4;i++) { funcs.push(function() { console.log(i); });}funcs.forEach(function() { fun();});如上代码所示，我们将var替换成了let，let是ES6声明变量的方法，此时let声明后i变成了块级作用域变量，也就是新建了一个块级作用域，在for内部i不再是同一个，而是在一个作用域中一个变量i。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}